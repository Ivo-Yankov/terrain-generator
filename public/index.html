<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
	<meta name="author" content="Corey Birnbaum" />
	<title>Grid</title>

	<style>
		body {
			overflow: hidden;
		}
		#view {
			position: absolute;
			top: 0;
			left: 0;
		}
	</style>
</head>

<body>

	<div id="view"></div>

	<script type="text/javascript" src="../lib/three.min.js"></script>
	<script type="text/javascript" src="../lib/OrbitControls.js"></script>
	<script type="text/javascript" src="../dist/hex-grid.min.js"></script>
	<script type="text/javascript">

	// Define global variables
	min_snow_height = 150;
	meshes_to_combine = [];

	objectTypes = {
		'grass' : {
			'r': 0.262745098,
			'g': 0.690196079,
			'b': 0.164705882
		}, 
		'water' : {
			'r': 0.2,
			'g': 0.2,
			'b': 1
		},
		'mountain' : {
			'r': 0.352941177,
			'g': 0.301960784,
			'b': 0.254901961
		},
		'mud' : {
			'r': 0.498039216,
			'g': 0.247058824,
			'b': 0
		},
		'tree-trunk' : {
			'r': 0.325490196,
			'g': 0.192156863,
			'b': 0.094117647
		},	
		'leaves' : {
			'r': 0.22745098,
			'g': 0.37254902,
			'b': 0.145098039
		},
		'snow' : {
			'r': 0.95,
			'g': 0.95,
			'b': 0.95
		}			
	};

	window.addEventListener('load', function(evt) {

		scene = new vg.Scene({
			element: document.getElementById('view'),
			cameraPosition: {x:1380, y:710, z:1327}
		}, {
			maxDistance: 2000,
		});

		// this constructs the cells in grid coordinate space
		grid = new vg.HexGrid({
			cellSize: 11 // size of individual cells
		});

		grid.generate({
			size: 60 // size of the board
		});

		board = new vg.Board(grid);

		board.generateTilemap({
			tileScale: 0.95
		});

		// scene.add(board.group);
		
		addSkyBox();

		reset_terrain_timer();
		reset_river_timer();

		generate_terrain();
		
		update();
	});

	function update() {
		scene.render();
		requestAnimationFrame(update);

		// Starts the generation of the rivers after the terrain is completed
		if( terrain_timer ) {
			terrain_timer--;
			if (terrain_timer == 0) {	//The terrain is generated
				window.terrain_generated = true;
				generate_river_flow();
			}
		}

		// Generates some objects after the rivers are done
		if ( window.terrain_generated && !window.rivers_generated && river_timer ) {
			river_timer--;
			if ( river_timer == 0 && !window.rivers_generated ) {	//The rivers are generated
				// Creates trees on grass and mountain tiles
				generate_trees();

				// Adds snow to the higher mountains and grass to the lower mountains
				generate_cover_tiles();

				mergeGeometries();

				window.rivers_generated = true;
			}
		}
	}	

	function reset_terrain_timer(){
		terrain_timer = 10;
	}

	function reset_river_timer(){
		river_timer = 10;
	}

	function generate_terrain() {
		// Set all cells to water
		for ( cell_index in grid.cells ) {
			if( grid.cells.hasOwnProperty(cell_index) ) {
				var cell = grid.cells[cell_index];
				setObjectType(cell, 'water');
			}
		}

		// Creates the starting tiles for the mountains and islands
		for ( cell_index in grid.cells ) {
			if ( grid.cells.hasOwnProperty(cell_index) ) {
				var cell = grid.cells[cell_index];
				var height_rand_seed = Math.random() * 100;

				// Generate a mountain
				if ( height_rand_seed >= 99.95 ) {
					height_value = Math.floor( Math.random() * 200 + 80 );
					setHeight(cell, height_value)
					smooth_height( cell, 0, 'steep' );
				}

				// Generate a flat land island
				else if ( height_rand_seed >= 99.90 ) {
					height_value = Math.floor( Math.random() * 15 + 10 );
					setHeight(cell, height_value)
					smooth_height( cell, 0, 'flat' );
				}
			}
		}
	}

	function smooth_height( origin_cell, distance, method ) {
		requestAnimationFrame( function() {
			distance++;
			var neighbors = grid.getNeighbors(origin_cell);
			
			reset_terrain_timer();
			
			for (var i = 0; i < neighbors.length; i++ ) {
				if ( !neighbors[i].userData.smooothed_height ) {
					neighbors[i].userData.smooothed_height = true;
					var origin_height = origin_cell.h;
					var height = 0;
					var rand_distance = 0;
					switch ( method ) {
						case 'steep': 
							height = Math.floor( origin_height * ( Math.random() * 0.35 + 0.7 ) );
							rand_distance = Math.floor(Math.random() * 9) + 20;
							break;
						case 'flat': 
							height = Math.floor( origin_height * ( Math.random() * 0.2 + 0.85 ) );
							rand_distance = Math.floor(Math.random() * 9) + 20;
							break;
					}

					setHeight(neighbors[i], height );

					// Create a water spring
					if ( height > 100 && Math.random() > 0.95 ) {
						neighbors[i].userData.water_spring = true;
						setObjectType(neighbors[i], 'water');
					}

					if ( distance < rand_distance && height > 1 ) {
						smooth_height( neighbors[i], distance, method );
					}

				}
			}

		});
	}

	function addSkyBox() {
		var geometry = new THREE.SphereGeometry(2000, 120, 80);  

		var material = new THREE.MeshPhongMaterial({
			color: '#8ACCFF'
		});

		skyBox = new THREE.Mesh(geometry, material);  
		skyBox.scale.set(-1, 1, 1);  
		skyBox.eulerOrder = 'XZY';  
		skyBox.renderDepth = 1000.0;  
		scene.add(skyBox);  
	}

	function check_generation_stage() {
		check_if_rivers_generated();
	}


	function generate_river_flow() {
		for ( cell_index in grid.cells ) {
			if ( grid.cells.hasOwnProperty(cell_index) ) {
				var cell = grid.cells[cell_index];
				if ( cell.userData.water_spring ) {
					flow_water_cell( cell );
				}
			}
		}
	}

	function flow_water_cell( cell ) {
		requestAnimationFrame( function() {
			reset_river_timer();

			cell.userData.flowing = true;
			var neighbors = grid.getNeighbors(cell);
			var min_height = 1000;
			var min_height_i = false;

			neighbors.sort(function(a, b) { 
			    return a.h - b.h;
			});

			var i = 0;
			while ( neighbors[i] && neighbors[i].userData.type === 'water' ) {
				i++;
			}

			if ( neighbors[i] && i < 2 ) {
				setObjectType(neighbors[i], 'water');
				flow_water_cell(neighbors[i]);
			}

		});
	}

	function generate_cover_tiles() {
		for ( cell_index in grid.cells ) {
			if ( grid.cells.hasOwnProperty(cell_index) ) {
				var cell = grid.cells[cell_index];
				if ( cell.userData.type == 'mountain' ) {

					if ( cell.h > min_snow_height ) {
						create_cover_tile({
								'x' : cell.tile.position.x,
								'y' : cell.h,
								'z' : cell.tile.position.z
							}, {
								'x' : 1,
								'y' : 1,
								'z' : 1
							}, 'snow');
					}
					else if ( cell.h < 50 ) {
						create_cover_tile({
							'x' : cell.tile.position.x,
							'y' : cell.h,
							'z' : cell.tile.position.z
						}, {
							'x' : 1,
							'y' : 1,
							'z' : 1
						}, 'grass');	
					}
				}
			}
		}
	}

	function create_cover_tile( position, scale, type ) {
		createNewTile ({
			'position': {
				'x': position.x,
				'y': position.y,
				'z': position.z
			},
			'scale': {
				'x': scale.x,
				'y': scale.y,
				'z': scale.z
			},
			'height' : 1,
			'type' : type
		});		
	}

	function generate_trees() {
		for ( cell_index in grid.cells ) {
			if ( grid.cells.hasOwnProperty(cell_index) ) {
				var cell = grid.cells[cell_index];
				if ( cell.userData.type == 'grass' || cell.userData.type == 'mountain' ) {
					var rand = Math.floor( Math.random() * 100 );

					var tree_chance = cell.userData.type == 'grass' ? 80 : 95;

					if ( rand > tree_chance ) {
						var y_pos = cell.h;
						var height = Math.floor( Math.random() * 5 + 10 );

						createNewTile ({
							'position': {
								'x': cell.tile.position.x,
								'y': y_pos,
								'z': cell.tile.position.z
							},
							'scale': {
								'x': 0.2,
								'y': 0.2,
								'z': 1
							},
							'height' : height,
							'type' : 'tree-trunk'
						});

						y_pos += height;
						var height = Math.floor( Math.random() * 5 + 10 );

						createNewTile ({
							'position': {
								'x': cell.tile.position.x,
								'y': y_pos,
								'z': cell.tile.position.z
							},
							'scale': {
								'x': 1,
								'y': 1,
								'z': 1
							},
							'height' : height,
							'type' : 'leaves'
						});

						if ( y_pos > min_snow_height ) {
							create_cover_tile({
								'x' : cell.tile.position.x,
								'y' : y_pos + height,
								'z' : cell.tile.position.z
							}, {
								'x' : 1,
								'y' : 1,
								'z' : 1
							}, 'snow');
						}

						y_pos += height;
						var height = Math.floor( Math.random() * 5 + 10 );

						createNewTile ({
							'position': {
								'x': cell.tile.position.x,
								'y': y_pos,
								'z': cell.tile.position.z
							},
							'scale': {
								'x': 0.5,
								'y': 0.5,
								'z': 1
							},
							'height' : height,
							'type' : 'leaves'
						});

						if ( y_pos > min_snow_height ) {
							create_cover_tile({
								'x' : cell.tile.position.x,
								'y' : y_pos + height,
								'z' : cell.tile.position.z
							}, {
								'x': 0.5,
								'y': 0.5,
								'z' : 1
							}, 'snow');
						}
					}
				}

			}
		}
	}


	function createNewTile( args ) {
		var settings = {
			tileScale: 0.95,
			cellSize: grid.cellSize,
			material: null,
			extrudeSettings: {
				amount: args.height || 1,
				bevelEnabled: true,
				bevelSegments: 1,
				steps: 1,
				bevelSize: 0.5,
				bevelThickness: 0.5
			}
		}

		var geometry = new THREE.ExtrudeGeometry(grid.cellShape, settings.extrudeSettings);

		var material = new THREE.MeshPhongMaterial({
			color: vg.Tools.randomizeRGB('30, 30, 30', 13)
		});

		var tile = new THREE.Mesh( geometry, material );

		if( args.type) {
			setTileColor( tile, args.type );
		}
		
		if ( args.position ) {
			tile.position.x = args.position.x;
			tile.position.y = args.position.y;
			tile.position.z = args.position.z;
		}		
		if ( args.scale ) {
			tile.scale.x = args.scale.x;
			tile.scale.y = args.scale.y;
			tile.scale.z = args.scale.z;
		}

		tile.rotation.x = -90 * vg.DEG_TO_RAD;
		// tile.scale.set(0.95, 0.95, 1);
		
		meshes_to_combine.push(tile);

		// scene.add(tile);
	}

	function setHeight(cell, height) {
		var settings = {
			tileScale: 0.95,
			cellSize: grid.cellSize,
			material: null,
			extrudeSettings: {
				amount: height,
				bevelEnabled: true,
				bevelSegments: 1,
				steps: 1,
				bevelSize: 0.5,
				bevelThickness: 0.5
			}
		}

		cell.h = height;		
		cell.tile.dispose();

		var tile = grid.generateTile(cell, settings.tileScale, settings.material);
		tile.position.copy(grid.cellToPixel(cell));
		tile.position.y = 0;
	
		board.tiles.push(tile);
		board.tileGroup.add(tile.mesh);

		if (height > 20) {
			setObjectType(cell, 'mountain');
		}
		else if(height > 2) {
			setObjectType(cell, 'grass');
		}
		else {
			setObjectType(cell, 'mud');
		}
	}

	function setObjectType(cell, cellType) {
		cell.userData.type = cellType;
		setTileColor(cell.tile, cellType);
	}

	function setTileColor(tile, type) {
		tile.material.color.r = objectTypes[type].r;
		tile.material.color.g = objectTypes[type].g;
		tile.material.color.b = objectTypes[type].b;
		tile.userData.type = type;
	}

	// function mergeMeshes (meshes, materials) {
	// 	var combined = new THREE.Geometry();
	// 	for (var i = 0; i < meshes.length; i++) {
	// 		meshes[i].updateMatrix();

	// 		for (var j = 0; j < meshes[j].geometry.faces.length; j++) {
	// 			meshes[j].geometry.faces[j].materialIndex = i;
	// 			meshes[j].geometry.faces[j].color.setRGB( meshes[i].material.color.r, meshes[i].material.color.g, meshes[i].material.color.b );
	// 		}

 //  // // for ( var i = 0; i < geometry.faces.length; i ++ ) {
 //  // //   geometry.faces[i].materialIndex = this.materials.length-1;
 //  // // }

	// 		combined.merge(meshes[i].geometry, meshes[i].matrix);
	// 	}

	// 	var mats = new THREE.MeshFaceMaterial(materials);

	// 	var mesh = new THREE.Mesh(combined, mats);

	// 	return mesh;
	// }


	function mergeMeshesAndMaterials (meshArr) {
	    var geometry = new THREE.Geometry(),
	        materials = [],
	        m,
	        materialPointer = 0,
	        reindex = 0;

	    for (var i = 0; i < meshArr.length; i++) {
	        m = meshArr[i];

	        if (m.material.materials) {
	            for (var j = 0; j < m.material.materials.length; j++) {
	                materials[materialPointer++] = m.material.materials[j];
	            }
	        } else if (m.material) {
	            materials[materialPointer++] = m.material;
	        }
	        geometry.merge(m.geometry, m.matrix, reindex);
	        
	        reindex = materialPointer;
	    }
	    return new THREE.Mesh(geometry, new THREE.MeshFaceMaterial(materials));
	};	

	function mergeMeshes (meshArr) {
	    var geometry = new THREE.Geometry();

	    for (var i = 0; i < meshArr.length; i++) {
	    	meshArr[i].updateMatrix();
	        geometry.merge(meshArr[i].geometry, meshArr[i].matrix);
	    }
	    var material = meshArr[0].material;

	    return new THREE.Mesh(geometry, material);
	};	


	function mergeGeometries() {
		var geometry;
		
		var material_meshes = [];
		for ( var object_type in objectTypes ) {
			if ( objectTypes.hasOwnProperty(object_type) ) {
				material_meshes[object_type] = [];
			}
		}

		for ( cell_index in grid.cells ) {
			if( grid.cells.hasOwnProperty(cell_index) ) {
				var cell = grid.cells[cell_index]; 
				cell.tile.mesh.userData.type = cell.tile.userData.type;
				meshes_to_combine.push(cell.tile.mesh);
			}
		}
		
		for ( var mesh_index in meshes_to_combine ) {
			if ( meshes_to_combine.hasOwnProperty(mesh_index) ) {
				var mesh = meshes_to_combine[mesh_index];
				if ( mesh.userData.type && material_meshes[mesh.userData.type] ) {
					material_meshes[mesh.userData.type].push(mesh);
				}
			}
		}

		for ( var mesh_type in material_meshes ) {
			if ( material_meshes.hasOwnProperty(mesh_type) ) {
				if ( material_meshes[mesh_type].length ) {
					var object = mergeMeshes( material_meshes[mesh_type] );
					scene.add(object);
				}
			}
		}

		for ( cell_index in grid.cells ) {
			if( grid.cells.hasOwnProperty(cell_index) ) {
				var cell = grid.cells[cell_index]; 
				cell.tile.dispose();
			}
		}
	}
	</script>
</body>
</html>